# Про использование моделей

В этом разделе подробно описано почему библиотека работает с 2мя слоями моделей. Для чего это нужно и какие из этого можно извлечь выгоды. 

Начнем с того, что еще раз перечслим слои:

1) **Raw Layer Models** - или `DTO` или `RawMappable`. Это модели нежнего уровня. Именно с этими моделями работают почти все стандартные узлы. 
2) **Application Layer Models** - или `DTOConvertible`. Это модели верхнего уровня. Эти модели можно смело использовать внутри презентеров и разных вью. Эти модели получаются из `DTO`

## Application Layer Models

Эти модели должны использоваться выше сервисов. Просто маппинг в них происходит в библиотеке для автоматизации этого процесса. 
Эти модели НЕ должны быть связаны с БД.
Иными словами это просто обычная модель. 

Процесс устроен таким образом, что при отправке запроса с этой моделью она практически сразу конвертируется в связанную с ней `DTO`-модель.
После получения ответа от сервера модель этого типа конвертируется из связанной с ней `DTO`-моделью тлоько в самом конце работы цепочки узлов. 

**Это бизнес-модели.**

## Raw Layer Models

Эти модели данных не должны использоваться НИ где, кроме узлов цепочки (и методов маппинга в `Application Layer Model`).
Эти модели можно использовать как сущности для хранения в БД. 

Модели такого типа в конечном итоге мапятся в RAW-данные и отправляются на сервер. Так же RAW-овтет сервера мапится на эти данные. 

**Это модели доступа к данным.**

## Как использовать два слоя моделей

На самом деле архитектура с двумя слоями моделей это давно устоявшийся подход и в разработке бэкэнда этот подход используется по-умолчанию. 

По-мимо очевидных положительных вещей (разделение логической ответственности на бизнес и небизнесс) есть следующие опложительные стороны:

### Пример 1. Замена значения. 

Допустим, у нас есть некоторый продукт. 

```Swift

struct Product: DTODecodable {
    let id: String
    let name: String
    let alias: String?

    func from(dto: ProductEntry) {
        return .init(id: dto.id, name: dto.name, alias: dto.alias)
    }
}
```

И требования такие:
1) Всегда выводить `alias` в качестве названия продукта. 
2) В случае если `alias == nil` или `alias.isEmpty`, то выводить `name` 

Эти требования обсулавливаются тем, что `alias` - задает пользователь, а `name` это имя продукта по-умолчанию. 

Понятное дело, то писать во всех местах что-то вроде:
```Swift
    if let alias = model.alias, !alias.isEmpty {
        self.productNameLabel.text = alias
    } else {
        self.productNameLabel.text = model.name
    }
```

Еще можно написать `extension` но это все равно выглядит немного костыльно. Считай лишнее поле добавили. 

Если у нас есть `DTO` слой, то эту проблему можно решить при маппинге данных:

```Swift
    func from(dto: ProductEntry) {
        let alias = {
            guard let alias = dto.alias, !alias.IsEmpty else {
                return dto.name
            }
            return alias
        }()
        return .init(id: dto.id, name: dto.name, alias: alias)
    }
```
